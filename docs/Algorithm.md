# Algorithm

## 搜索二叉树
定义：左节点比父节点小，右节点比父节点大
校验：中序遍历 升序

## 图
表示：邻接表法/邻接矩阵法/数组

## 完全二叉树
1>如果树为空，则直接返回错
2>如果树不为空：层序遍历二叉树
2.1>如果一个结点左右孩子都不为空，则pop该节点，将其左右孩子入队列；
2.1>如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树；
2.2>如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空，且则该节点之后的队列中的结点都为叶子节点，该树才是完全二叉树，否则就不是完全二叉树;

## 满二叉树
一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是2^k^ -1 ，则它就是满二叉树。

## 堆
堆(Heap)最高效的优先级队列。可以被看作一棵完全二叉树的数组对象。

## 哈希
输入域无穷大，输出区域有限
相同的输入，相同的输出，会出现不同的输入，相同的输出，因为输入域无穷大，输入域有限，概率极低
输出域离散性极度均匀
MD5:0～2^64^ -1,16个字符，16进制
SHA1:0~2^128^ -1，32个字符，16进制
哈希槽（Array）每个槽挂链表

## 布隆过滤器
没有删除，只有添加和查询

## 一致性哈希
哈希操，虚拟节点

## 树形DP
1.以某个节点X为头节点的子树中，分析答案有哪些可能性，并且这种分析是以X的左子树，X的右子树和X的整棵树的角度来考虑可能性的；
2.根据第一步的可能性分析，列出所需要的信息；
3.合并第二步的信息，对左树和右树提出同样的要求，并写出信息的结构；
4.设计递归函数，递归函数是处理以X为头节点的情况下的答案；
包括设计递归函数的Base Case，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三部的信息结构

## Morris遍历
假设来到当前节点Current，开始时Current来到头节点位置
1 如果Current没有左孩子，Current向右移动（Current=Current.Right）
2 如果Current有左孩子，找到左子树上最右的节点MostRight；
    a 如果MostRight的右指针指向null，让其指向Current，然后Current向左移动(Current=Current.Left)；
    b 如果MostRight的右指针指向Current，让其指向null，然后Current向右移动(Current=Current.Right)；
3 Current为空时遍历停止；

## 有序表 O(logN)
1.红黑树，AVL树，Size-Balance Tree，跳表
2.平衡搜索二叉树系列，上面前三,搜索二叉树上默认无重复值；
3.删除节点，然后用左树最右的节点或者右树最左的节点替代；
4.平衡树，任何一个节点，左树和右树的高度差不大于1；